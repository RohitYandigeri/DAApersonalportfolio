<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAA Lab Reflections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2 {
            color: #333;
        }
        ul {
            margin: 10px 0 20px 20px;
        }
        li {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>DAA Lab Reflections</h1>

    <h2>1. What are the challenges in learning/understanding the above concepts?</h2>
    <ul>
        <li><strong>Time Complexity Analysis:</strong>
            <ul>
                <li>Understanding asymptotic notations like Big-O, Omega, and Theta can be abstract and difficult to visualize.</li>
                <li>Comparing the efficiency of different algorithms analytically requires a strong mathematical foundation.</li>
            </ul>
        </li>
        <li><strong>Binary Search Tree (BST):</strong>
            <ul>
                <li>Grasping the recursive nature of operations like insertion, deletion, and traversal.</li>
                <li>Visualizing the tree structure and identifying cases where the BST becomes unbalanced.</li>
            </ul>
        </li>
        <li><strong>DFS and BFS:</strong>
            <ul>
                <li>Managing large graphs and understanding traversal order, especially in edge cases like cyclic or disconnected graphs.</li>
                <li>Debugging stack/queue-based implementations can be tricky.</li>
            </ul>
        </li>
        <li><strong>Heap:</strong>
            <ul>
                <li>Understanding how heap properties are maintained during operations like insertion and heapify.</li>
                <li>Differentiating between min-heaps and max-heaps and their applications.</li>
            </ul>
        </li>
        <li><strong>Sorting:</strong>
            <ul>
                <li>Identifying which sorting algorithm is most efficient for a given dataset or problem.</li>
                <li>Understanding advanced sorting techniques like quicksort and mergesort in terms of their recursion and partitioning.</li>
            </ul>
        </li>
        <li><strong>Pattern Searching:</strong>
            <ul>
                <li>Implementing algorithms like KMP or Rabin-Karp correctly and understanding their preprocessing steps.</li>
                <li>Handling overlapping patterns in strings or large datasets efficiently.</li>
            </ul>
        </li>
        <li><strong>Graph Algorithms:</strong>
            <ul>
                <li>Visualizing and solving problems involving weighted, directed, or cyclic graphs.</li>
                <li>Understanding advanced algorithms like Dijkstra’s, Bellman-Ford, or Floyd-Warshall.</li>
            </ul>
        </li>
    </ul>

    <h2>2. What are the challenges in correlating with real-world applications?</h2>
    <ul>
        <li><strong>Time Complexity Analysis:</strong> Balancing theoretical complexity with real-world performance bottlenecks caused by hardware or constraints.</li>
        <li><strong>Binary Search Tree (BST):</strong>
            <ul>
                <li>Understanding how BSTs are used in database indexing or file systems.</li>
                <li>Correlating unbalanced trees with degraded performance in real-world scenarios.</li>
            </ul>
        </li>
        <li><strong>DFS and BFS:</strong>
            <ul>
                <li>Applying DFS to backtracking problems like solving mazes or puzzles.</li>
                <li>Using BFS in applications like shortest path routing or social network analysis.</li>
            </ul>
        </li>
        <li><strong>Heap:</strong>
            <ul>
                <li>Mapping heap usage to scenarios like task scheduling or implementing priority queues.</li>
                <li>Understanding real-world applications in memory management or dynamic median finding.</li>
            </ul>
        </li>
        <li><strong>Sorting:</strong> Identifying sorting needs in data processing, e.g., ranking, arranging, or data visualization.</li>
        <li><strong>Pattern Searching:</strong> Relating pattern searching to text analysis, log filtering, or genome sequencing.</li>
        <li><strong>Graph Algorithms:</strong>
            <ul>
                <li>Recognizing use cases in transport systems, like Dijkstra’s algorithm for shortest path computation.</li>
                <li>Applying graph coloring or flow algorithms to practical problems like resource allocation or network optimization.</li>
            </ul>
        </li>
    </ul>

    <h2>3. How do you determine the most efficient approach/design techniques when solving a complex problem?</h2>
    <ul>
        <li><strong>Time Complexity Analysis:</strong> Analyze the size of the input and evaluate which algorithm can handle the worst-case scenario within acceptable time.</li>
        <li><strong>Binary Search Tree (BST):</strong> Use BSTs only when dynamic insertion, deletion, and search are required, ensuring balance for efficiency.</li>
        <li><strong>DFS and BFS:</strong> Use BFS for shortest path problems in unweighted graphs and DFS for connectivity or cycle detection.</li>
        <li><strong>Heap:</strong> Apply heaps when prioritization is required, e.g., finding the k largest or smallest elements.</li>
        <li><strong>Sorting:</strong> For nearly sorted data, use insertion sort; for large datasets, prefer quicksort or mergesort for efficiency.</li>
        <li><strong>Pattern Searching:</strong> Choose algorithms like KMP or Rabin-Karp when searching multiple patterns or when preprocessing is needed.</li>
        <li><strong>Graph Algorithms:</strong> Opt for Dijkstra’s algorithm for shortest paths in weighted graphs with non-negative edges and Bellman-Ford for graphs with negative weights.</li>
    </ul>
</body>
</html>
